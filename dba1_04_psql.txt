psql 

####
select schemaname, tablename, tableowner from pg_tables limit 10;
      
  
Команда SQL может занимать и несколько строк,точка с запятой завершает ее.

select schemaname, tablename, tableowner
from pg_tables limit 10;
      


Если вывод команды SQL не помещется на экран, для его отображения можно использовать специальную программу $PAGER.
Использование можно включать или выключать с помощью \pset pager on|off



Для управления выводом используется команда \pset в разных вариациях.
Например, можно включить отображение полей "в столбик":
\pset expanded on|off
или просто \x

\pset expanded on
      

select schemaname, tablename, tableowner from pg_tables limit 2;
   
\pset expanded off
      



Если вывод предстоит разбирать программно, то можно:
а) убрать выравнивание полей

        => \pset format unaligned
        Output format is unaligned.

б) убрать вывод заголовка таблицы

        => \pset tuples_only on
        Tuples only is on.

в) заменить разделитель

        => \pset fieldsep ' '
        Field separator is " ".

-----------------------------------------------------------------------

Посмотрим на результат:

select schemaname, tablename, tableowner from pg_tables limit 10;


...и вернем обратно:

        => \pset format aligned
        Output format is aligned.

        => \pset tuples_only off
        Tuples only is off.

-----------------------------------------------------------------------

Можно включить формат вывода HTML:

\pset format html
 

select schemaname, tablename, tableowner from pg_tables limit 1;
   

\pset format aligned


Можно выполнять команды shell:

\! ls | head -n 10
  

\! pwd
     


Для изменения текущего (для psql) каталога есть специальная команда:

\! pwd
       
\cd ..

\! pwd
  
\cd practice


Можно установить переменную окружения:

\! echo $TEST
        

\setenv TEST Hello

\! echo $TEST
    
Можно записать вывод команды в файл с помощью \o[ut]:

\o dba1_log

\select schemaname, tablename, tableowner from pg_tables limit 5;

На экран ничего не попало. Посмотрим в файле:

\! cat dba1_log
        

Вернем вывод на экран:

\o

Запишем в файл команды SQL.


\a
Output format is unaligned.

\t
Tuples only is on.

\pset fieldsep ' '
Field separator is " ".

\o dba1_log

select 'select count(*) from', tablename, ';' from pg_tables limit 3;

\o

\t
Tuples only is off.

\a
Output format is aligned.

-----------------------------------------------------------------------

Вот что получилось в файле:

\! cat dba1_log

И выполним теперь эти команды с помощью \i[nclude]:

\i dba1_log
Другие способы выполнить команды из файла:
а) psql < filename
б) psql -f filename
в) psql -c command (работает только для одной команды)

Файл также можно отредактировать, не выходя из psql, с помощью \e[dit] filename,
при этом используется редактор $PSQL_EDITOR (или $EDITOR, или $VISUAL)

-----------------------------------------------------------------------

Последняя команда SQL попадает в буфер запроса.

Выполним команду и выведем содержимое буфера с помощью \p[rint]:

select now();
        
\p

Выполним команду, не вводя ее заново (в остальном \g аналогична точке с запятой):
\g

Можно записать содержимое буфера в файл с помощью \w[rite]:

\w dba1_log

\! cat dba1_log

Наконец, очистим буфер с помощью \r[eset]:

\r
Query buffer reset (cleared).

\p
Query buffer is empty.


Можно периодически выполнять команду из буфера с помощью \watch seconds

Буфер также можно отредактировать с помощью \e[dit], после чего отредактированная команда выполнится.

-----------------------------------------------------------------------

По аналогии с shell, psql имеет собственные переменные,
среди которых есть ряд встроенных (имеющих определенный смысл для psql).

Установим переменную:

        => \set TEST Hi!

Чтобы получить значение, надо предварить имя переменной двоеточием:

        => \echo :TEST
        Hi!

Значение переменной можно сбросить:

        => \unset TEST

        => \echo :TEST
        :TEST

Можно установить значение переменной результатом запроса с помощью \gset вместо точки с запятой:

select now() as curr_time \gset

        => \echo :curr_time
        2015-12-30 15:27:01.98212+03

Значение переменной можно запросить и у пользователя с помощью \prompt text name
А также указать при запуске: psql -v name=value


Без параметров \set выдает значения всех переменных:

\set

С помощью серии команд, начинающихся на \d, можно смотреть информацию об объектах БД.
Например:

        => \d+ pg_rules
                       View "pg_catalog.pg_rules"
           Column   | Type | Modifiers | Storage  | Description 
        ------------+------+-----------+----------+-------------
         schemaname | name |           | plain    | 
         tablename  | name |           | plain    | 
         rulename   | name |           | plain    | 
         definition | text |           | extended | 
        View definition:
         SELECT n.nspname AS schemaname,
            c.relname AS tablename,
            r.rulename,
            pg_get_ruledef(r.oid) AS definition
           FROM pg_rewrite r
             JOIN pg_class c ON c.oid = r.ev_class
             LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
          WHERE r.rulename <> '_RETURN'::name;
        


При сборке с библиотекой Readline имеются дополнительные возможности.

Во-первых, редактирование команд и их история, как в shell.
Управляющие переменные:

        => \echo :HISTCONTROL
        :HISTCONTROL

        => \echo :HISTFILE
        hist

        => \echo :HISTSIZE
        :HISTSIZE

Историю можно сохранить в файл с помощью \s filename

-----------------------------------------------------------------------

Во-вторых, автодополнение имен объектов БД по клавише TAB.
Регистр символов при автодополнении определяется переменной:

        => \echo :COMP_KEYWORD_CASE
        :COMP_KEYWORD_CASE


\q
