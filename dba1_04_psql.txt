
-----------------------------------------------------------------------

Последняя команда SQL попадает в буфер запроса.

Выполним команду и выведем содержимое буфера с помощью \p[rint]:

select now();
        
\p

Выполним команду, не вводя ее заново (в остальном \g аналогична точке с запятой):
\g

Можно записать содержимое буфера в файл с помощью \w[rite]:

\w dba1_log

\! cat dba1_log

Наконец, очистим буфер с помощью \r[eset]:

\r
Query buffer reset (cleared).

\p
Query buffer is empty.


Можно периодически выполнять команду из буфера с помощью \watch seconds

Буфер также можно отредактировать с помощью \e[dit], после чего отредактированная команда выполнится.

-----------------------------------------------------------------------

По аналогии с shell, psql имеет собственные переменные,
среди которых есть ряд встроенных (имеющих определенный смысл для psql).

Установим переменную:

        => \set TEST Hi!

Чтобы получить значение, надо предварить имя переменной двоеточием:

        => \echo :TEST
        Hi!

Значение переменной можно сбросить:

        => \unset TEST

        => \echo :TEST
        :TEST

Можно установить значение переменной результатом запроса с помощью \gset вместо точки с запятой:

select now() as curr_time \gset

        => \echo :curr_time
        2015-12-30 15:27:01.98212+03

Значение переменной можно запросить и у пользователя с помощью \prompt text name
А также указать при запуске: psql -v name=value


Без параметров \set выдает значения всех переменных:

\set

С помощью серии команд, начинающихся на \d, можно смотреть информацию об объектах БД.
Например:

        => \d+ pg_rules
                       View "pg_catalog.pg_rules"
           Column   | Type | Modifiers | Storage  | Description 
        ------------+------+-----------+----------+-------------
         schemaname | name |           | plain    | 
         tablename  | name |           | plain    | 
         rulename   | name |           | plain    | 
         definition | text |           | extended | 
        View definition:
         SELECT n.nspname AS schemaname,
            c.relname AS tablename,
            r.rulename,
            pg_get_ruledef(r.oid) AS definition
           FROM pg_rewrite r
             JOIN pg_class c ON c.oid = r.ev_class
             LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
          WHERE r.rulename <> '_RETURN'::name;
        


При сборке с библиотекой Readline имеются дополнительные возможности.

Во-первых, редактирование команд и их история, как в shell.
Управляющие переменные:

        => \echo :HISTCONTROL
        :HISTCONTROL

        => \echo :HISTFILE
        hist

        => \echo :HISTSIZE
        :HISTSIZE

Историю можно сохранить в файл с помощью \s filename

-----------------------------------------------------------------------

Во-вторых, автодополнение имен объектов БД по клавише TAB.
Регистр символов при автодополнении определяется переменной:

        => \echo :COMP_KEYWORD_CASE
        :COMP_KEYWORD_CASE


\q
